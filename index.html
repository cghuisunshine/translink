<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TransLink Realtime (Stop / Route / Both)</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.06);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --border: rgba(255,255,255,0.12);
      --accent: #7dd3fc;
      --danger: #fb7185;
      --ok: #34d399;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(125,211,252,0.18), transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, rgba(52,211,153,0.12), transparent 60%),
                  var(--bg);
      color: var(--text);
    }

    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 18px 60px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 18px;
      margin-bottom: 16px;
    }

    h1 {
      font-size: 18px;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    @media (min-width: 900px) {
      .grid {
        grid-template-columns: 1.05fr 0.95fr;
        align-items: start;
      }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      backdrop-filter: blur(10px);
    }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 10px 0 6px;
    }

    input, select, button {
      font: inherit;
    }

    input, select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      outline: none;
    }

    input:focus, select:focus {
      border-color: rgba(125, 211, 252, 0.55);
      box-shadow: 0 0 0 3px rgba(125,211,252,0.16);
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 160px;
      gap: 10px;
    }

    .btnrow {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(125, 211, 252, 0.14);
      color: var(--text);
      cursor: pointer;
    }

    button:hover {
      border-color: rgba(125, 211, 252, 0.55);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .pill {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 16px;
      white-space: pre-wrap;
    }

    .status .ok { color: var(--ok); }
    .status .bad { color: var(--danger); }

    .mono {
      font-family: var(--mono);
    }

    .results {
      display: grid;
      gap: 10px;
    }

    .kvs {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 12px;
      font-size: 13px;
      line-height: 1.35;
    }

    .kvs div:nth-child(odd) {
      color: var(--muted);
    }

    .list {
      margin: 8px 0 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 8px;
    }

    .list li {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.22);
    }

    .list .top {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .list .muted {
      color: var(--muted);
      font-size: 12px;
    }

    footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
    }

    a { color: var(--accent); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>TransLink Realtime (Stop / Route / Both)</h1>
        <div class="hint">
          Use either: stop+route (realtime), route-only (list stops + start time), or stop-only (list routes + times).
        </div>
      </div>
      <div class="pill" title="Uses TransLink public GTFS APIs">
        <span>API:</span>
        <span class="mono">getaway.translink.ca</span>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="row">
          <div>
          <label for="stopSpec">Stop (name or stop ID)</label>
          <input id="stopSpec" placeholder="e.g. Westbound Yew or 60574 (leave blank for route-only)" autocomplete="off" />
          </div>
          <div>
            <label for="routeNo">Route #</label>
            <input id="routeNo" list="routeList" placeholder="e.g. 7 (leave blank for stop-only)" autocomplete="off" />
            <datalist id="routeList"></datalist>
            <div class="hint" id="routeHint" style="margin-top: 6px;"></div>
          </div>
        </div>

        <div class="btnrow">
          <button id="searchBtn">Search</button>
          <button id="realtimeBtn" disabled>Fetch</button>
          <button id="nearbyBtn" type="button">Nearby (GPS)</button>
          <button id="clearBtn" type="button">Clear</button>
        </div>

        <div class="status" id="status"></div>

        <label for="stopSelect">Matching stops</label>
        <select id="stopSelect" size="10"></select>

        <footer>
          Tip: Use <span class="mono">Nearby (GPS)</span> to list stops near you. Leave one field blank for single-parameter mode.
        </footer>
      </section>

      <section class="card results">
        <div class="kvs" id="info"></div>
        <ul class="list" id="departures"></ul>
      </section>
    </div>
  </div>

  <script>
    // Metro Vancouver bounds used by TransLink's own Next Bus UI.
    // Source: https://www.translink.ca/js/gtfsHelpers.mjs
    const GVTA = {
      north: 49.47671,
      west: -123.43833,
      south: 49.0,
      east: -122.30006,
    };

    const STOP_CACHE_KEY = "translink_gtfs_stops_cache_v1";
    const STOP_CACHE_TTL_MS = 24 * 60 * 60 * 1000;

    const stopSpecEl = document.getElementById("stopSpec");
    const routeNoEl = document.getElementById("routeNo");
    const searchBtn = document.getElementById("searchBtn");
    const realtimeBtn = document.getElementById("realtimeBtn");
    const nearbyBtn = document.getElementById("nearbyBtn");
    const clearBtn = document.getElementById("clearBtn");
    const stopSelectEl = document.getElementById("stopSelect");
    const routeListEl = document.getElementById("routeList");
    const routeHintEl = document.getElementById("routeHint");
    const statusEl = document.getElementById("status");
    const infoEl = document.getElementById("info");
    const departuresEl = document.getElementById("departures");

    const routeCache = new Map(); // stopId -> routes array

    function setStatus(message, kind = "") {
      statusEl.innerHTML = "";
      if (!message) return;
      const span = document.createElement("span");
      if (kind === "ok") span.className = "ok";
      if (kind === "bad") span.className = "bad";
      span.textContent = message;
      statusEl.appendChild(span);
    }

    function isStopId(value) {
      return /^\d{5}$/.test((value || "").trim());
    }

    function normalizeRouteForCompare(value) {
      const raw = (value || "").trim();
      if (!raw) return "";
      if (/^\d+$/.test(raw)) return String(parseInt(raw, 10));
      return raw.toLowerCase();
    }

    function formatRouteForApi(value) {
      const raw = (value || "").trim();
      if (!raw) return "";
      if (/^\d+$/.test(raw)) return String(parseInt(raw, 10)).padStart(3, "0");
      return raw.toUpperCase();
    }

    function tokenizeQuery(value) {
      const tokens = (value || "")
        .toLowerCase()
        .split(/\s+/)
        .map((t) => t.trim())
        .filter((t) => t.length > 1);
      return Array.from(new Set(tokens));
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const toRad = (d) => (d * Math.PI) / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function optionTextToStopName(text) {
      const raw = String(text || "").trim();
      if (!raw) return "";

      // Expected formats:
      // - "60574 — Westbound W 4th Ave @ Yew St"
      // - "60574 — Westbound W 4th Ave @ Yew St (123m)"
      const parts = raw.split(/\s+—\s+/);
      const rhs = parts.length >= 2 ? parts.slice(1).join(" — ") : raw;
      return rhs.replace(/\s*\(\d+m\)\s*$/, "").trim();
    }

    function getCurrentPosition(options) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error("Geolocation is not supported in this browser."));
          return;
        }
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }

    async function fetchJson(url) {
      const response = await fetch(url, {
        headers: {
          accept: "application/json",
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} for ${url}`);
      }
      return response.json();
    }

    function loadStopsCache() {
      try {
        const raw = localStorage.getItem(STOP_CACHE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.ts || !parsed.data) return null;
        if (Date.now() - parsed.ts > STOP_CACHE_TTL_MS) return null;
        return parsed.data;
      } catch {
        return null;
      }
    }

    function saveStopsCache(stops) {
      try {
        localStorage.setItem(
          STOP_CACHE_KEY,
          JSON.stringify({ ts: Date.now(), data: stops })
        );
      } catch {
        // ignore quota / privacy mode
      }
    }

    async function getStops() {
      const cached = loadStopsCache();
      if (cached) return cached;

      const url = `https://getaway.translink.ca/api/gtfs/stops/${GVTA.north},${GVTA.west}/${GVTA.south},${GVTA.east}`;
      setStatus("Downloading stop list (cached for 24h)...");
      const data = await fetchJson(url);
      saveStopsCache(data);
      return data;
    }

    async function getRoutesForStop(stopId) {
      if (routeCache.has(stopId)) return routeCache.get(stopId);
      const url = `https://getaway.translink.ca/api/gtfs/stop/${encodeURIComponent(stopId)}/routes`;
      const routes = await fetchJson(url);
      routeCache.set(stopId, routes);
      return routes;
    }

    function clearRouteSuggestions() {
      routeListEl.innerHTML = "";
      routeHintEl.textContent = "";
    }

    function renderRouteSuggestions(routes) {
      routeListEl.innerHTML = "";

      if (!Array.isArray(routes) || routes.length === 0) {
        routeHintEl.textContent = "";
        return;
      }

      const uniq = new Map();
      for (const r of routes) {
        const key = normalizeRouteForCompare(r?.rs || "");
        if (!key) continue;
        if (!uniq.has(key)) uniq.set(key, r);
      }

      const list = Array.from(uniq.values()).sort((a, b) => {
        const aa = normalizeRouteForCompare(a?.rs || "");
        const bb = normalizeRouteForCompare(b?.rs || "");
        const aNum = /^\d+$/.test(aa) ? Number(aa) : NaN;
        const bNum = /^\d+$/.test(bb) ? Number(bb) : NaN;
        if (!Number.isNaN(aNum) && !Number.isNaN(bNum)) return aNum - bNum;
        return String(aa).localeCompare(String(bb));
      });

      for (const r of list) {
        const opt = document.createElement("option");
        opt.value = normalizeRouteForCompare(r?.rs || "");
        opt.textContent = `${r?.rs || ""} ${r?.rl || ""}`.trim();
        routeListEl.appendChild(opt);
      }

      const preview = list
        .slice(0, 12)
        .map((r) => normalizeRouteForCompare(r?.rs || ""))
        .filter(Boolean)
        .join(", ");

      routeHintEl.textContent = `Routes at this stop: ${preview}${list.length > 12 ? "…" : ""}`;
    }

    async function refreshRouteSuggestionsForStop(stopId) {
      if (!stopId) {
        clearRouteSuggestions();
        return;
      }

      try {
        const routes = await getRoutesForStop(stopId);
        renderRouteSuggestions(routes);
      } catch {
        clearRouteSuggestions();
      }
    }

    async function stopHasRoute(stopId, routeNoNormalized) {
      const routes = await getRoutesForStop(stopId);
      return (
        Array.isArray(routes) &&
        routes.some((r) => normalizeRouteForCompare(r?.rs || "") === routeNoNormalized)
      );
    }

    async function filterByRouteWithConcurrency(stops, routeNoNormalized, onProgress) {
      const concurrency = 8;
      const results = [];
      let index = 0;
      let done = 0;

      async function worker() {
        while (true) {
          const current = index++;
          if (current >= stops.length) return;

          const stop = stops[current];
          const stopId = stop.sc;

          try {
            const ok = await stopHasRoute(stopId, routeNoNormalized);
            if (ok) results.push(stop);
          } catch {
            // If this call fails, keep the stop so users can still pick.
            results.push(stop);
          } finally {
            done++;
            onProgress?.(done);
          }
        }
      }

      const workers = Array.from({ length: Math.min(concurrency, stops.length) }, () => worker());
      await Promise.all(workers);

      // Preserve original order for stability
      const keepIds = new Set(results.map((s) => s.sc));
      return stops.filter((s) => keepIds.has(s.sc));
    }

    function clearResults() {
      infoEl.innerHTML = "";
      departuresEl.innerHTML = "";
    }

    function applySelectedStopToInput() {
      const opt = stopSelectEl.options[stopSelectEl.selectedIndex];
      if (!opt) return;
      const stopName = optionTextToStopName(opt.textContent);
      stopSpecEl.value = stopName || opt.value || "";
      updateButtons();
    }

    function setInfoRows(rows) {
      infoEl.innerHTML = "";
      for (const [k, v] of rows) {
        const kEl = document.createElement("div");
        kEl.textContent = k;
        const vEl = document.createElement("div");
        vEl.textContent = v;
        infoEl.appendChild(kEl);
        infoEl.appendChild(vEl);
      }
    }

    function renderStopOptions(stops) {
      stopSelectEl.innerHTML = "";
      for (const s of stops) {
        const opt = document.createElement("option");
        opt.value = s.sc;
        opt.textContent = `${s.sc} — ${s.sn}`;
        stopSelectEl.appendChild(opt);
      }
      if (stopSelectEl.options.length === 1) {
        stopSelectEl.selectedIndex = 0;
      }
      updateButtons();

      const selectedStopId = stopSelectEl.value;
      refreshRouteSuggestionsForStop(selectedStopId);
    }

    async function showNearbyStops() {
      clearResults();
      stopSelectEl.innerHTML = "";
      updateButtons();

      setStatus("Requesting GPS location...");

      let pos;
      try {
        pos = await getCurrentPosition({ enableHighAccuracy: false, timeout: 8000, maximumAge: 30000 });
      } catch (e) {
        const code = e?.code;
        const msg =
          code === 1
            ? "Location permission denied."
            : code === 2
              ? "Location unavailable."
              : code === 3
                ? "Location request timed out."
                : String(e?.message || e);
        setStatus(msg, "bad");
        return;
      }

      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      setStatus("Finding nearby stops...");
      const allStops = await getStops();

      const nearby = allStops
        .filter((s) => typeof s?.la === "number" && typeof s?.lo === "number")
        .map((s) => ({
          ...s,
          _dist: haversineMeters(lat, lon, s.la, s.lo),
        }))
        .filter((s) => s._dist <= 600)
        .sort((a, b) => a._dist - b._dist)
        .slice(0, 25);

      if (nearby.length === 0) {
        setStatus("No stops found within ~600m. Try searching by name.", "bad");
        return;
      }

      stopSelectEl.innerHTML = "";
      for (const s of nearby) {
        const opt = document.createElement("option");
        opt.value = s.sc;
        opt.textContent = `${s.sc} — ${s.sn} (${Math.round(s._dist)}m)`;
        stopSelectEl.appendChild(opt);
      }

      stopSelectEl.selectedIndex = 0;
      setStatus(`Found ${nearby.length} nearby stop(s).`, "ok");
      updateButtons();
      refreshRouteSuggestionsForStop(stopSelectEl.value);
    }

    function updateButtons() {
      const stopSpec = stopSpecEl.value.trim();
      const routeNo = routeNoEl.value.trim();
      const hasSelectedStop = Boolean(stopSelectEl.value);

      // Enable realtimeBtn when it can do something useful:
      // - stop+route (needs selected stop)
      // - stop-only (needs selected stop)
      // - route-only (no stop needed)
      const canFetch =
        (routeNo && hasSelectedStop) ||
        (!routeNo && hasSelectedStop) ||
        (!stopSpec && routeNo);

      realtimeBtn.disabled = !canFetch;
    }

    async function showRouteStops(routeNo) {
      clearResults();
      stopSelectEl.innerHTML = "";
      updateButtons();

      const routeApi = formatRouteForApi(routeNo);
      const routeNormalized = normalizeRouteForCompare(routeNo);

      if (!routeApi) {
        setStatus("Enter a route #.", "bad");
        return;
      }

      setStatus(`Fetching stops for route ${routeNo} (both directions)...`);

      const rows = [["Mode", "Route-only"], ["Route", routeNormalized]];
      const listItems = [];

      for (const dir of [0, 1]) {
        const stopsUrl = `https://getaway.translink.ca/api/gtfs/route/${encodeURIComponent(routeApi)}/direction/${dir}/stops`;
        const nextTripUrl = `https://getaway.translink.ca/api/gtfs/route/${encodeURIComponent(routeApi)}/direction/${dir}/nexttrip`;

        let stops = [];
        let nextTripLocal = "";

        try {
          stops = await fetchJson(stopsUrl);
        } catch (e) {
          rows.push([`Direction ${dir}`, `Failed to fetch stops (${String(e?.message || e)})`]);
          continue;
        }

        try {
          const nextTrip = await fetchJson(nextTripUrl);
          const unix = nextTrip?.nextTripDateTimeInUnix;
          if (typeof unix === "number") {
            nextTripLocal = new Date(unix * 1000).toLocaleString([], {
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
            });
          }
        } catch {
          // optional
        }

        const first = Array.isArray(stops) && stops.length > 0 ? stops[0] : null;
        const startText = first ? `${first.sn} (${first.sc})` : "(unknown)";
        rows.push([`Dir ${dir} start`, nextTripLocal ? `${startText} · next trip ${nextTripLocal}` : startText]);

        if (!Array.isArray(stops) || stops.length === 0) {
          listItems.push({ header: `Direction ${dir} stops`, detail: "No stops returned." });
          continue;
        }

        listItems.push({ header: `Direction ${dir} stops`, detail: `${stops.length} stops` });
        stops.forEach((s, idx) => {
          listItems.push({
            header: `${s?.sn || ""}`,
            right: `${s?.sc || ""}`,
            detail: `dir ${dir} · #${idx + 1}`,
          });
        });
      }

      setInfoRows(rows);
      departuresEl.innerHTML = "";

      for (const item of listItems) {
        const li = document.createElement("li");

        const top = document.createElement("div");
        top.className = "top";

        const left = document.createElement("div");
        left.textContent = item.header || "";

        const right = document.createElement("div");
        right.className = "mono";
        right.textContent = item.right || "";

        top.appendChild(left);
        if (item.right) top.appendChild(right);

        li.appendChild(top);

        if (item.detail) {
          const meta = document.createElement("div");
          meta.className = "muted";
          meta.textContent = item.detail;
          li.appendChild(meta);
        }

        departuresEl.appendChild(li);
      }

      setStatus("OK", "ok");
    }

    async function showRoutesAtStop(stopId) {
      clearResults();

      if (!stopId) {
        setStatus("Pick a stop first.", "bad");
        return;
      }

      setStatus(`Fetching routes for stop ${stopId}...`);

      const routes = await getRoutesForStop(stopId);
      if (!Array.isArray(routes) || routes.length === 0) {
        setStatus("No routes found for this stop.", "bad");
        return;
      }

      setInfoRows([["Mode", "Stop-only"], ["Stop", stopId], ["Routes", String(routes.length)]]);
      departuresEl.innerHTML = "";

      const concurrency = 5;
      let idx = 0;
      let done = 0;

      async function worker() {
        while (true) {
          const current = idx++;
          if (current >= routes.length) return;

          const r = routes[current];
          const rs = r?.rs || "";
          const rl = r?.rl || "";
          const di = r?.di;
          const dn = r?.dn || "";

          const routeApi = formatRouteForApi(rs);
          const url = `https://getaway.translink.ca/api/gtfs/stop/${encodeURIComponent(stopId)}/route/${encodeURIComponent(routeApi)}/realtimeschedules?querySize=3`;

          let times = [];
          let noRealtime = false;

          try {
            const json = await fetchJson(url);
            times = json?.[0]?.r?.[0]?.t?.map((t) => t?.dt).filter(Boolean) || [];
          } catch {
            noRealtime = true;
          }

          const li = document.createElement("li");

          const top = document.createElement("div");
          top.className = "top";

          const left = document.createElement("div");
          left.textContent = `${rs} ${rl}`.trim() + (dn ? ` (→ ${dn})` : "") + (typeof di === "number" ? ` [dir ${di}]` : "");

          const right = document.createElement("div");
          right.className = "mono";
          right.textContent = times.length ? times.join(", ") : "";

          top.appendChild(left);
          top.appendChild(right);

          li.appendChild(top);

          const meta = document.createElement("div");
          meta.className = "muted";
          meta.textContent = noRealtime ? "realtime unavailable" : (times.length ? "" : "no upcoming times");
          if (meta.textContent) li.appendChild(meta);

          departuresEl.appendChild(li);

          done++;
          if (done % 5 === 0 || done === routes.length) {
            setStatus(`Fetching route times… ${done}/${routes.length}`);
          }
        }
      }

      const workers = Array.from({ length: Math.min(concurrency, routes.length) }, () => worker());
      await Promise.all(workers);

      setStatus("OK", "ok");
    }

    async function searchStops() {
      clearResults();
      stopSelectEl.innerHTML = "";
      updateButtons();

      const stopSpec = stopSpecEl.value.trim();
      const routeNo = routeNoEl.value.trim();

      // Route-only mode
      if (!stopSpec && routeNo) {
        await showRouteStops(routeNo);
        return;
      }

      if (!stopSpec) {
        setStatus("Enter a stop (name or ID), or a route #.", "bad");
        return;
      }

      if (isStopId(stopSpec)) {
        const allStops = await getStops();
        const match = allStops.find((s) => s?.sc === stopSpec);
        setStatus(`Using stop ID ${stopSpec}.`, "ok");
        renderStopOptions([{ sc: stopSpec, sn: match?.sn || "(stop ID)", la: null, lo: null }]);
        return;
      }

      const tokens = tokenizeQuery(stopSpec);
      if (tokens.length === 0) {
        setStatus("Type at least 2 characters for stop name.", "bad");
        return;
      }

      const allStops = await getStops();
      const nameMatches = allStops
        .filter((s) => {
          const sn = (s?.sn || "").toLowerCase();
          return tokens.every((t) => sn.includes(t));
        })
        .sort((a, b) => (a.sn || "").localeCompare(b.sn || ""));

      if (nameMatches.length === 0) {
        setStatus(`No stop names match “${stopSpec}”.`, "bad");
        renderStopOptions([]);
        return;
      }

      // Stop-only mode: just show name matches.
      if (!routeNo) {
        const maxToShow = 60;
        const toShow = nameMatches.slice(0, maxToShow);
        setStatus(`Found ${nameMatches.length} matching stop(s). Showing ${toShow.length}.`, "ok");
        renderStopOptions(toShow);
        return;
      }

      // Stop+route mode: filter by route service at the stop.
      const routeNoNormalized = normalizeRouteForCompare(routeNo);

      // Cap how many we route-check to keep it responsive.
      const maxToCheck = 40;
      const toCheck = nameMatches.slice(0, maxToCheck);

      setStatus(`Found ${nameMatches.length} name matches. Checking route ${routeNo} for up to ${toCheck.length} stops...`);
      let lastShown = 0;

      const filtered = await filterByRouteWithConcurrency(toCheck, routeNoNormalized, (done) => {
        const pct = Math.floor((done / toCheck.length) * 100);
        if (pct - lastShown >= 10 || done === toCheck.length) {
          lastShown = pct;
          setStatus(`Route-checking… ${done}/${toCheck.length} (${pct}%)`);
        }
      });

      if (filtered.length === 0) {
        setStatus(`No matches verified on route ${routeNo}. Showing name matches (first ${toCheck.length}).`, "bad");
        renderStopOptions(toCheck);
        return;
      }

      setStatus(`Filtered to ${filtered.length} stop(s) serving route ${routeNo}.`, "ok");
      renderStopOptions(filtered);
    }

    async function getRealtime() {
      clearResults();

      const stopSpec = stopSpecEl.value.trim();
      const routeNo = routeNoEl.value.trim();
      const selectedStopId = stopSelectEl.value;

      // Route-only mode
      if (!stopSpec && routeNo) {
        await showRouteStops(routeNo);
        return;
      }

      // Stop-only mode
      if (!routeNo && selectedStopId) {
        await showRoutesAtStop(selectedStopId);
        return;
      }

      // Stop+route mode
      if (!routeNo || !selectedStopId) {
        setStatus("Pick a stop and enter a route # (or leave one blank for single-parameter mode).", "bad");
        return;
      }

      const routeApi = formatRouteForApi(routeNo);
      const url = `https://getaway.translink.ca/api/gtfs/stop/${encodeURIComponent(selectedStopId)}/route/${encodeURIComponent(routeApi)}/realtimeschedules?querySize=6`;

      setStatus(`Fetching realtime for stop ${selectedStopId}, route ${routeNo}...`);
      const json = await fetchJson(url);

      if (!Array.isArray(json) || json.length === 0) {
        setStatus("No realtime data for this stop/route.", "bad");
        return;
      }

      const stop = json[0];
      const route = stop?.r?.[0];
      const trips = route?.t || [];

      setInfoRows([
        ["Mode", "Stop+route"],
        ["Stop", stop?.sn || ""],
        ["Route", `${route?.rs || ""} ${route?.rl || ""}`.trim()],
        ["Destination", route?.dn || ""],
      ]);

      departuresEl.innerHTML = "";
      for (const t of trips) {
        const li = document.createElement("li");

        const top = document.createElement("div");
        top.className = "top";

        const left = document.createElement("div");
        left.textContent = `${t?.th || ""}`;

        const right = document.createElement("div");
        right.className = "mono";
        right.textContent = `${t?.dt || ""}`;

        top.appendChild(left);
        top.appendChild(right);

        const meta = document.createElement("div");
        meta.className = "muted";
        const delay = typeof t?.dl === "number" ? `${t.dl}s` : "";
        const rt = typeof t?.rt === "boolean" ? (t.rt ? "realtime" : "scheduled") : "";
        meta.textContent = [delay && `delay ${delay}`, rt].filter(Boolean).join(" · ");

        li.appendChild(top);
        if (meta.textContent) li.appendChild(meta);

        departuresEl.appendChild(li);
      }

      setStatus("OK", "ok");
    }

    function clearAll() {
      stopSpecEl.value = "";
      routeNoEl.value = "";
      stopSelectEl.innerHTML = "";
      clearRouteSuggestions();
      clearResults();
      setStatus("");
      updateButtons();
    }

    searchBtn.addEventListener("click", () => {
      searchStops().catch((e) => setStatus(String(e?.message || e), "bad"));
    });

    realtimeBtn.addEventListener("click", () => {
      getRealtime().catch((e) => setStatus(String(e?.message || e), "bad"));
    });

    nearbyBtn.addEventListener("click", () => {
      showNearbyStops().catch((e) => setStatus(String(e?.message || e), "bad"));
    });

    clearBtn.addEventListener("click", clearAll);

    stopSelectEl.addEventListener("change", () => {
      updateButtons();
      refreshRouteSuggestionsForStop(stopSelectEl.value);
    });

    stopSelectEl.addEventListener("dblclick", () => {
      applySelectedStopToInput();
      stopSpecEl.focus();
    });

    let stopIdSuggestTimer = null;
    stopSpecEl.addEventListener("input", () => {
      updateButtons();

      const stopSpec = stopSpecEl.value.trim();
      if (!isStopId(stopSpec)) return;

      if (stopIdSuggestTimer) window.clearTimeout(stopIdSuggestTimer);
      stopIdSuggestTimer = window.setTimeout(() => {
        refreshRouteSuggestionsForStop(stopSpec);
      }, 250);
    });

    routeNoEl.addEventListener("input", updateButtons);

    stopSpecEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") searchBtn.click();
    });

    routeNoEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") searchBtn.click();
    });
    updateButtons();

    // Best-effort default stop list from GPS.
    // Geolocation often requires https:// or localhost, and may require user interaction.
    if (window.isSecureContext && navigator.geolocation) {
      showNearbyStops().catch(() => {
        // ignore; user can click Nearby (GPS)
      });
    }

  </script>
</body>
</html>
